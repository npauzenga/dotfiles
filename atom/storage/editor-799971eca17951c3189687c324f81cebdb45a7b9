{"mode":"editor","version":1,"windowDimensions":{"x":0,"y":23,"width":1027,"height":873,"maximized":false},"grammars":{"deserializer":"GrammarRegistry","grammarOverridesByPath":{}},"project":{"paths":["/Users/nate/.rvm/gems/ruby-2.2.1/bundler/gems/faker-89b4206886bd"],"buffers":[{"text":"# -*- coding: utf-8 -*-\nmydir = File.expand_path(File.dirname(__FILE__))\n\nbegin\n  require 'psych'\nrescue LoadError\nend\n\nrequire 'i18n'\nrequire 'set' # Fixes a bug in i18n 0.6.11\n\nif I18n.respond_to?(:enforce_available_locales=)\n  I18n.enforce_available_locales = true\nend\nI18n.load_path += Dir[File.join(mydir, 'locales', '*.yml')]\n\n\nmodule Faker\n  class Config\n    @locale = nil\n\n    class << self\n      attr_writer :locale\n      def locale\n        @locale || I18n.locale\n      end\n    end\n  end\n\n  class Base\n    Numbers = Array(0..9)\n    ULetters = Array('A'..'Z')\n    Letters = ULetters + Array('a'..'z')\n\n    class << self\n      ## make sure numerify results doesnâ€™t start with a zero\n      def numerify(number_string)\n        number_string.sub(/#/) { (rand(9)+1).to_s }.gsub(/#/) { rand(10).to_s }\n      end\n\n      def letterify(letter_string)\n        letter_string.gsub(/\\?/) { ULetters.sample }\n      end\n\n      def bothify(string)\n        letterify(numerify(string))\n      end\n\n      # Given a regular expression, attempt to generate a string\n      # that would match it.  This is a rather simple implementation,\n      # so don't be shocked if it blows up on you in a spectacular fashion.\n      #\n      # It does not handle ., *, unbounded ranges such as {1,},\n      # extensions such as (?=), character classes, some abbreviations\n      # for character classes, and nested parentheses.\n      #\n      # I told you it was simple. :) It's also probably dog-slow,\n      # so you shouldn't use it.\n      #\n      # It will take a regex like this:\n      #\n      # /^[A-PR-UWYZ0-9][A-HK-Y0-9][AEHMNPRTVXY0-9]?[ABEHMNPRVWXY0-9]? {1,2}[0-9][ABD-HJLN-UW-Z]{2}$/\n      #\n      # and generate a string like this:\n      #\n      # \"U3V  3TP\"\n      #\n      def regexify(re)\n        re = re.source if re.respond_to?(:source) # Handle either a Regexp or a String that looks like a Regexp\n        re.\n          gsub(/^\\/?\\^?/, '').gsub(/\\$?\\/?$/, '').                                                                      # Ditch the anchors\n          gsub(/\\{(\\d+)\\}/, '{\\1,\\1}').gsub(/\\?/, '{0,1}').                                                             # All {2} become {2,2} and ? become {0,1}\n          gsub(/(\\[[^\\]]+\\])\\{(\\d+),(\\d+)\\}/) {|match| $1 * Array(Range.new($2.to_i, $3.to_i)).sample }.                # [12]{1,2} becomes [12] or [12][12]\n          gsub(/(\\([^\\)]+\\))\\{(\\d+),(\\d+)\\}/) {|match| $1 * Array(Range.new($2.to_i, $3.to_i)).sample }.                # (12|34){1,2} becomes (12|34) or (12|34)(12|34)\n          gsub(/(\\\\?.)\\{(\\d+),(\\d+)\\}/) {|match| $1 * Array(Range.new($2.to_i, $3.to_i)).sample }.                      # A{1,2} becomes A or AA or \\d{3} becomes \\d\\d\\d\n          gsub(/\\((.*?)\\)/) {|match| match.gsub(/[\\(\\)]/, '').split('|').sample }.                                      # (this|that) becomes 'this' or 'that'\n          gsub(/\\[([^\\]]+)\\]/) {|match| match.gsub(/(\\w\\-\\w)/) {|range| Array(Range.new(*range.split('-'))).sample } }. # All A-Z inside of [] become C (or X, or whatever)\n          gsub(/\\[([^\\]]+)\\]/) {|match| $1.split('').sample }.                                                          # All [ABC] become B (or A or C)\n          gsub('\\d') {|match| Numbers.sample }.\n          gsub('\\w') {|match| Letters.sample }\n      end\n\n      # Helper for the common approach of grabbing a translation\n      # with an array of values and selecting one of them.\n      def fetch(key)\n        fetched = translate(\"faker.#{key}\")\n        fetched = fetched.sample if fetched.respond_to?(:sample)\n        if fetched.match(/^\\//) and fetched.match(/\\/$/) # A regex\n          regexify(fetched)\n        else\n          fetched\n        end\n      end\n\n      # Load formatted strings from the locale, \"parsing\" them\n      # into method calls that can be used to generate a\n      # formatted translation: e.g., \"#{first_name} #{last_name}\".\n      def parse(key)\n        fetch(key).scan(/(\\(?)#\\{([A-Za-z]+\\.)?([^\\}]+)\\}([^#]+)?/).map {|prefix, kls, meth, etc|\n          # If the token had a class Prefix (e.g., Name.first_name)\n          # grab the constant, otherwise use self\n          cls = kls ? Faker.const_get(kls.chop) : self\n\n          # If an optional leading parentheses is not present, prefix.should == \"\", otherwise prefix.should == \"(\"\n          # In either case the information will be retained for reconstruction of the string.\n          text = prefix\n\n          # If the class has the method, call it, otherwise\n          # fetch the transation (i.e., faker.name.first_name)\n          text += cls.respond_to?(meth) ? cls.send(meth) : fetch(\"#{(kls || self).to_s.split('::').last.downcase}.#{meth.downcase}\")\n\n          # And tack on spaces, commas, etc. left over in the string\n          text += etc.to_s\n        }.join\n      end\n\n      # Call I18n.translate with our configured locale if no\n      # locale is specified\n      def translate(*args)\n        opts = args.last.is_a?(Hash) ? args.pop : {}\n        opts[:locale] ||= Faker::Config.locale\n        opts[:raise] = true\n        I18n.translate(*(args.push(opts)))\n      rescue I18n::MissingTranslationData\n        # Super-simple fallback -- fallback to en if the\n        # translation was missing.  If the translation isn't\n        # in en either, then it will raise again.\n        I18n.translate(*(args.push(opts.merge(:locale => :en))))\n      end\n\n      def flexible(key)\n        @flexible_key = key\n      end\n\n      # You can add whatever you want to the locale file, and it will get caught here.\n      # E.g., in your locale file, create a\n      #   name:\n      #     girls_name: [\"Alice\", \"Cheryl\", \"Tatiana\"]\n      # Then you can call Faker::Name.girls_name and it will act like #first_name\n      def method_missing(m, *args, &block)\n        super unless @flexible_key\n\n        # Use the alternate form of translate to get a nil rather than a \"missing translation\" string\n        if translation = translate(:faker)[@flexible_key][m]\n          translation.respond_to?(:sample) ? translation.sample : translation\n        else\n          super\n        end\n      end\n\n      # Generates a random value between the interval\n      def rand_in_range(from, to)\n        from, to = to, from if to < from\n        Random.new.rand(from..to)\n      end\n    end\n  end\nend\n\nrequire 'faker/address'\nrequire 'faker/code'\nrequire 'faker/color'\nrequire 'faker/company'\nrequire 'faker/university'\nrequire 'faker/finance'\nrequire 'faker/internet'\nrequire 'faker/lorem'\nrequire 'faker/name'\nrequire 'faker/team'\nrequire 'faker/phone_number'\nrequire 'faker/business'\nrequire 'faker/commerce'\nrequire 'faker/version'\nrequire 'faker/number'\nrequire 'faker/bitcoin'\nrequire 'faker/avatar'\nrequire 'faker/date'\nrequire 'faker/time'\nrequire 'faker/number'\nrequire 'faker/hacker'\nrequire 'faker/app'\nrequire 'faker/slack_emoji'\nrequire 'faker/book'\nrequire 'faker/hipster'\n\nrequire 'extensions/array'\nrequire 'extensions/symbol'\n\nrequire 'helpers/char'\n","markerStore":{"nextMarkerId":1,"markersById":{"0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","editorId":8},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}},"version":2},"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/nate/.rvm/gems/ruby-2.2.1/bundler/gems/faker-89b4206886bd/lib/faker.rb","digestWhenLastPersisted":"9bf868a3d0361d0345b8ead87958e30d028fca18","preferredLineEnding":null,"deserializer":"TextBuffer","version":2}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":3,"items":[{"id":8,"softTabs":true,"displayBuffer":{"id":9,"softWrapped":false,"scrollTop":3217,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/nate/.rvm/gems/ruby-2.2.1/bundler/gems/faker-89b4206886bd/lib/faker.rb","largeFileMode":false,"deserializer":"TokenizedBuffer"},"largeFileMode":false,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"}],"activeItemURI":"/Users/nate/.rvm/gems/ruby-2.2.1/bundler/gems/faker-89b4206886bd/lib/faker.rb","focused":false,"flexScale":1,"deserializer":"Pane"},"activePaneId":3,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-ruby","language-hyperlink","language-todo"],"deserializer":"Workspace"},"packageStates":{"fuzzy-finder":{"/Users/nate/.rvm/gems/ruby-2.2.1/bundler/gems/faker-89b4206886bd/lib/faker.rb":1445696334973},"metrics":{"sessionLength":10625},"tabs":[{}],"tree-view":{"directoryExpansionStates":{"/Users/nate/.rvm/gems/ruby-2.2.1/bundler/gems/faker-89b4206886bd":{"isExpanded":true,"entries":{".git":{"isExpanded":false,"entries":{}},"lib":{"isExpanded":true,"entries":{"extensions":{"isExpanded":false,"entries":{}},"faker":{"isExpanded":true,"entries":{}},"helpers":{"isExpanded":false,"entries":{}},"locales":{"isExpanded":false,"entries":{}}}},"script":{"isExpanded":false,"entries":{}},"tasks":{"isExpanded":false,"entries":{}},"test":{"isExpanded":false,"entries":{}},"website":{"isExpanded":false,"entries":{}}}}},"selectedPath":"/Users/nate/.rvm/gems/ruby-2.2.1/bundler/gems/faker-89b4206886bd/lib/faker.rb","hasFocus":true,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}